索引:
    MyISAM和InnoDB存储引擎只支持Btree

读写分离：
    垂直分库：按照功能的不同，把没有关联的数据放到不同的数据库和服务器上
    水平分表：根据一定的规则(比如1年前的数据)把数据划分到不同的数据库中，两个数据库的表结构一样
    原理：mysql的主从复制，主数据库负责事务的增删改，从数据库负责select，读写分离的基础是在主从复制上
    类型：
        基于代码内部实现
        基于中间代理层(数据库中间件: maxsacle、Keepalived lvs)


sql及索引的优化：
    使用join连接代替子查询
    用exists代替in
    避免在索引列上使用计算
    避免在索引列上使用is null 和 is not null
    字段最好定宽，可以把content字段放到单独一张表
    字段尽量加not null约束
    避免全表扫描，考虑在where 和 order by涉及的列上加索引

事务的ACID：
    A(atomicity) 原子性    C(Consistency) 一致性      I(Isolation)隔离性     D(Durability)持续性

mysql事务隔离级别：
    read uncommitted：未提交读/脏读
        所有事务都可以看到其他事务未提交的执行结果
    read committed：提交读/不可重复读(大多数数据库默认)
        解决脏读的问题，只能读到已提交的事务操作结果，不可重复读：事务A在执行过程中进行了两次查询，在两次查询间事务B对数据进行了修改，导致事务A两次的查询结果不一样
            重点在于update和delete
    repeatable read：可重复读(mysql默认级别)
        保证了在同一事务内多次读取同一条记录得到的结果都一样。产生幻读：当事务A在读一个范围数据两次时，期间事务B对该范围的数据进行了修改，导致第二次读取会产生幻行。
            重点在于insert。innoDB 存储引擎通过多版本并发控制(mvcc)解决了幻读的问题
    serializable: 可串行化
        强制事务串行执行，会导致大量的锁竞争和加锁问题，会耗费大量的资源，在对数据要求一致性较高的地方使用

悲观锁：
    对数据的修改持保守态度，在整个数据处理中，将数据处于锁定状态，读取数据是需要加锁。
乐观锁：
    基于数据版本，为数据增加一个版本标识，读取数据时版本号一同读出，更新时版本号+1，将提交的版本号与数据库的版本号做对比，如果大于就更新，否则就认为时过期数据