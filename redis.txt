redis的数据类型:
    string, list(链表), set(集合), zset(sortedSet 有序集合), hash(hash类型)


redis分布式锁:
    服务端角度：
        1.先用setNX去争抢锁, 抢到之后再用expire给锁设置一个过期时间防止锁忘记释放
        2.如果在setNx之后执行expire之前进程意外crash了?
            可以使用set和expire合成一条指令
        3.假如redis里有1亿个key，其中有10W个是以一个固定的前缀开头的，如何找出来他们?
            可以使用keys指令扫出指定模式的key列表
        4.如果这个redis正在给线上使用，keys指令会有什么问题
            因为redis是单线程的，所以服务会阻塞一段时间，当查询完以后，服务才可以恢复，可以使用scan指令，可以无阻塞的取出key，但是会有一定的重复，
                在客户端去重，但是整体花费的时间要比keys指令用时长
        5.如何用redis做异步队列？
            一般使用list结构作为队列，rpush生产消息，lpop消费消息，在没有消息的时候，使用sleep阻塞一会再试
        6.可不可以不用sleep？
            list有个指令blpop，在没有消息的时候它会阻塞住，直到消息的到来
        7.能不能生产一次消费多次呢？
            使用pub/sub主题订阅者模式，可以实现1:N的消息队列
        8.pub/sub有什么缺点？
        当生产者下线的时候，生产的消息会被清楚掉，得使用专业的消息队列，robbitMq，activeMq

redis并发竞争的问题：
    使用java锁来使程序与redis进行通信


redis如何做持久化的：
    RDB：进程数据写入文件
        手动触发：
            bgsave  create一个子进程，由子进程来create rdb文件，父进程则继续处理请求
            save    会阻塞进程
        自动触发：
            save m n    指定当m秒内发生n次变化时，会触发bgsave
        执行流程：
            1.父进程首先判断当前是否在执行save、bgsave/bgrewriteaof的子进程，如果有则直接返回
            2.父进程执行fork操作create子进程，这个过程父进程是阻塞的，不能执行来自client的任何命令
            3.父进程fork后，bgsave会返回background saving started 信息不再阻塞父进程
            4.子进程creater RDB文件，根据父进程的内存快照生成临时的快照文件，完成后对原有的文件进行原子替换
            5.子进程发送信号给父进程表示完成，父进程更新统计信息
        优点：
            体积小、适合全量复制、恢复速度比aof快、对性能影响小、rdb文件需要满足特定的格式，兼容性差(老版本的redis不兼容新版本的rdb文件)
        缺点：
            做不到实时持久化

    AOF：将Redis执行的每次写命令记录到单独的日志文件中
        默认开启RDB，关闭AOF，配置文件中配置开启：appendonly yes
        执行流程：
            命令追加(append) 将redis的写命令追加到缓冲区aof_buf
            文件写入(write)和文件同步(sync)：根据不同的同步策略将aof_buf中的内容同步到硬盘
            文件重写(rewrite)定期重写aof文件，达到压缩的目的
            文件重写的触发：
                手动触发：bgrewriteaof 同rdb的bgsave一样fork操作
                自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数，以及aof_current_size和aof_base_size状态确定触发时机
        优点：
            支持秒级持久化，兼容性好
        缺点：
            文件大、恢复速度慢、对性能影响大


redis的数据淘汰策略：
    1.volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
    2.volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据进行淘汰
    3.volatile-random 从已设置过期时间的数据集中任意选择数据淘汰
    4.allkeys-lru 从数据集中挑选最近最少使用的数据淘汰
    5.allkeys-random 从数据集中任意选择数据进行淘汰
    6.no-enviction 禁止驱逐数据


缓存穿透：
    指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果DB层查不到数据则不写到缓存里，这将导致这个不存在的数据
        每次请求都要到DB里去查询，失去了缓存的意义，在流量大时，DB可能就挂了

解决方法：
    1.采用布隆过滤器将有可能的数据都缓存到一个大的bitmap里，一个不存在的数据会被这个bitmap拦截掉，从而避免了对DB的查询压力
    2.如果一个查询返回的数据为空，仍然把它缓存起来，但是它的过期时间很短，最长不超过5min


缓存雪崩：
    指在我们设置缓存时采用了同样的失效时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过大造成雪崩

解决方法：
    可以在原有的失效时间再加一个随机值，这样每一个缓存的的过期时间重复就会降低，就很难发生集体失效的事件


缓存击穿：
    缓存在某个时间点过期的时候，恰好这个时间点对应的key有大量的并发请求过来，这些请求过来发现缓存过期一般都会从后端DB数据加载到缓存，这个时候大的并发请求有可能
        把后端的DB压垮

解决方法：
    1.采用mutex，就是在key失效的时候，不是立即去load DB，而是先使用缓存工具操作(带成功返回的操作比如Redis的SETNX「SET if Not eXists」)去set一个mutex key，
        当返回操作成功的时候再进行load DB，否则就重试get()
    2.
        (1)永远不过期
        (2)把过期时间存到value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建