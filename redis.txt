redis的数据类型:
    string, list(链表), set(集合), zset(sortedSet 有序集合), hash(hash类型)


redis分布式锁:
    服务端角度：
        1.先用setNX去争抢锁, 抢到之后再用expire给锁设置一个过期时间防止锁忘记释放
        2.如果在setNx之后执行expire之前进程意外crash了?
            可以使用set和expire合成一条指令
        3.假如redis里有1亿个key，其中有10W个是以一个固定的前缀开头的，如何找出来他们?
            可以使用keys指令扫出指定模式的key列表
        4.如果这个redis正在给线上使用，keys指令会有什么问题
            因为redis是单线程的，所以服务会阻塞一段时间，当查询完以后，服务才可以恢复，可以使用scan指令，可以无阻塞的取出key，但是会有一定的重复，
                在客户端去重，但是整体花费的时间要比keys指令用时长
        5.如何用redis做异步队列？
            一般使用list结构作为队列，rpush生产消息，lpop消费消息，在没有消息的时候，使用sleep阻塞一会再试
        6.可不可以不用sleep？
            list有个指令blpop，在没有消息的时候它会阻塞住，直到消息的到来
        7.能不能生产一次消费多次呢？
            使用pub/sub主题订阅者模式，可以实现1:N的消息队列
        8.pub/sub有什么缺点？
        当生产者下线的时候，生产的消息会被清楚掉，得使用专业的消息队列，robbitMq，activeMq

redis并发竞争的问题：
    使用java锁来使程序与redis进行通信


redis如何做持久化的：
    RDB：
        手动触发：
            bgsave  create一个子进程，由子进程来create rdb文件，父进程则继续处理请求
            save    会阻塞进程
        自动触发：
            save m n    指定当m秒内发生n次变化时，会触发bgsave
    AOF：




redis的数据淘汰策略：
    1.volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
    2.volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据进行淘汰
    3.volatile-random 从已设置过期时间的数据集中任意选择数据淘汰
    4.allkeys-lru 从数据集中挑选最近最少使用的数据淘汰
    5.allkeys-random 从数据集中任意选择数据进行淘汰
    6.no-enviction 禁止驱逐数据


缓存穿透：
    指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果DB层查不到数据则不写到缓存里，这将导致这个不存在的数据
        每次请求都要到DB里去查询，失去了缓存的意义，在流量大时，DB可能就挂了

解决方法：
    1.采用布隆过滤器将有可能的数据都缓存到一个大的bitmap里，一个不存在的数据会被这个bitmap拦截掉，从而避免了对DB的查询压力
    2.如果一个查询返回的数据为空，仍然把它缓存起来，但是它的过期时间很短，最长不超过5min


缓存雪崩：
    指在我们设置缓存时采用了同样的失效时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过大造成雪崩

解决方法：
    可以在原有的失效时间再加一个随机值，这样每一个缓存的的过期时间重复就会降低，就很难发生集体失效的事件


缓存击穿：
    缓存在某个时间点过期的时候，恰好这个时间点对应的key有大量的并发请求过来，这些请求过来发现缓存过期一般都会从后端DB数据加载到缓存，这个时候大的并发请求有可能
        把后端的DB压垮

解决方法：
    1.采用mutex，就是在key失效的时候，不是立即去load DB，而是先使用缓存工具操作(带成功返回的操作比如Redis的SETNX「SET if Not eXists」)去set一个mutex key，
        当返回操作成功的时候再进行load DB，否则就重试get()
    2.
        (1)永远不过期
        (2)把过期时间存到value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建