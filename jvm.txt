jvm内存结构：
    1.堆内存(heap) all thread share，new出来的对象实例和数组都分配在这已区域，gc的处理也多在这一部分
        新生代：
            Eden空间：
            From Survivor空间：
            To Survivor空间：
        老年代：
    2.方法区(method area) all thread share 已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码
        运行时常量池：用于存放编译期生成的各种字面量和符号引用
    3.虚拟机栈 vm stack 线程独有 存放8种基本类型的数据和对象引用
    4.本地方法栈 native method stack 与虚拟机栈类似，主要为调用native方法服务 hotSpot虚拟机中和vm stack合为一体
    5.程序计数器(PC 寄存器) 线程独有 当前线程执行到到哪一字节码的记录(分支、跳转、循环、异常处理、线程恢复的控制)

GC：
    引用计数算法：给对象添加一个引用计数器，当有地方使用时，计数器就+1，当引用失效时，就-1，当计数器为0时，该对象就是不可能在被使用的
    可达性分析算法：程序中分配了许多GC Roots，从GC Roots开始向下搜索，当一个对象到GC Roots没有任何引用链的时候，此对象就是不可用的
        GC Roots包括：
            虚拟机栈中引用的对象
            本地方法栈中引用的对象
            方法区中静态属性引用的对象
            方法区中常量引用的对象

    垃圾收集算法：
        标记-清除算法
        复制算法：新生代使用，Eden 、From Survivor、To Survivor：8:1:1
        标记-整理算法：老年代使用



类加载机制：
    java代码编译生成.class文件(字节码，class文件是一组以8位字节为基础单位的二进制流)，所谓类的加载就是把class文件读到内存中

    1.加载：
        通过类的全限定名来获取定义此类的二进制字节流
        将这个字节流的静态存储结构转化为方法区的运行时数据结构
        在堆中生成一个java.lang.Class对象，作为方法区的这个类的各种数据的访问入口
    2.链接：
        1) 验证：验证class文件中的字节流信息是否符合当前虚拟机的要求，保证不会危害到虚拟机，此阶段可以被关闭
        2) 准备：正式为类变量(被static修饰的变量)分配内存空间和默认值
        3) 解析：虚拟机将常量池内的符号引用替换为直接引用的过程
    3.初始化：
        对类的静态变量，静态代码块执行初始化操作

    类初始化时机：
        创建类的实例(new)
        访问某个类或接口的静态变量，或者对该静态变量赋值
        调用静态方法
        反射调用 比如Class.forName("com.mysql.jdbc.Driver")
        初始化某个类的子类，则其父类也会被初始化
        java虚拟机启动时被表明为启动类的类

    类加载器：
        java虚拟机角度：
            1.启动类加载器(Bootstrap Classloader)，用c++实现，是虚拟机的不一部分
            2.其他的类加载器，用java语音实现，独立与虚拟机外部，都继承自抽象类java.lang.Classloader
        java开发人员角度：
            1.启动类加载器(Bootstrap Classloader),无法被java程序直接调用，负责加载存放在JAVA_HOME\lib目录中的，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被Bootstrap ClassLoader加载)
            2.扩展类加载器(Extension Classloader),开发者可以直接调用，负责加载JAVA_HOME/lib/ext目录中的类或者被java.ext.dirs系统变量所指定的路径中的所有类库
            3.应用程序类加载器(Application Classloader),开发者可以直接调用，一般情况下就是程序中默认的类加载器，负责加载类用户路径所指定的类

    双亲委派模式：
        如果一个类加载器收到类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给他的父类，所有的层次都是如此，因此所有的加载请求最终都应该传送到
            顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个类加载请求(它的搜索范围没有找到这个类)，子加载器才会尝试自己去加载



